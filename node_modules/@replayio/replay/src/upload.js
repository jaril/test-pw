"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildRecordingMetadata = exports.setRecordingMetadata = exports.closeConnection = exports.connectionReportCrash = exports.connectionUploadSourcemap = exports.connectionUploadRecording = exports.connectionWaitForProcessed = exports.connectionProcessRecording = exports.connectionCreateRecording = exports.initConnection = void 0;
const crypto_1 = __importDefault(require("crypto"));
const client_1 = __importDefault(require("./client"));
const utils_1 = require("./utils");
const metadata_1 = require("../metadata");
let gClient;
let gClientReady = (0, utils_1.defer)();
async function initConnection(server, accessToken, verbose, agent) {
    if (!gClient) {
        let { resolve } = gClientReady;
        gClient = new client_1.default(server, {
            async onOpen() {
                try {
                    await gClient.setAccessToken(accessToken);
                    resolve(true);
                }
                catch (err) {
                    (0, utils_1.maybeLog)(verbose, `Error authenticating with server: ${err}`);
                    resolve(false);
                }
            },
            onClose() {
                resolve(false);
            },
            onError(e) {
                (0, utils_1.maybeLog)(verbose, `Error connecting to server: ${e}`);
                resolve(false);
            },
        }, {
            agent,
        });
    }
    return gClientReady.promise;
}
exports.initConnection = initConnection;
async function connectionCreateRecording(id, buildId) {
    if (!gClient)
        throw new Error("Protocol client is not initialized");
    const { recordingId } = await gClient.sendCommand("Internal.createRecording", {
        buildId,
        // 3/22/2022: Older builds use integers instead of UUIDs for the recording
        // IDs written to disk. These are not valid to use as recording IDs when
        // uploading recordings to the backend.
        recordingId: (0, utils_1.isValidUUID)(id) ? id : undefined,
        // Ensure that if the upload fails, we will not create
        // partial recordings.
        requireFinish: true,
    });
    return recordingId;
}
exports.connectionCreateRecording = connectionCreateRecording;
function buildRecordingMetadata(metadata, opts = {}) {
    // extract the "standard" metadata and route the `rest` through the sanitizer
    const { duration, url, uri, title, operations, ...rest } = metadata;
    const metadataUrl = url || uri;
    return {
        recordingData: {
            duration: typeof duration === "number" ? duration : 0,
            url: typeof metadataUrl === "string" ? metadataUrl : "",
            title: typeof title === "string" ? title : "",
            operations: operations && typeof operations === "object" ? operations : {
                scriptDomains: [],
            },
            lastScreenData: "",
            lastScreenMimeType: "",
        },
        metadata: (0, metadata_1.sanitize)(rest),
    };
}
exports.buildRecordingMetadata = buildRecordingMetadata;
async function setRecordingMetadata(id, metadata) {
    if (!gClient)
        throw new Error("Protocol client is not initialized");
    metadata.recordingData.id = id;
    await gClient.sendCommand("Internal.setRecordingMetadata", metadata);
}
exports.setRecordingMetadata = setRecordingMetadata;
function connectionProcessRecording(recordingId) {
    if (!gClient)
        throw new Error("Protocol client is not initialized");
    gClient.sendCommand("Recording.processRecording", { recordingId });
}
exports.connectionProcessRecording = connectionProcessRecording;
async function connectionWaitForProcessed(recordingId) {
    if (!gClient)
        throw new Error("Protocol client is not initialized");
    const { sessionId } = await gClient.sendCommand("Recording.createSession", {
        recordingId,
    });
    const waiter = (0, utils_1.defer)();
    gClient.setEventListener("Recording.sessionError", ({ message }) => waiter.resolve(`session error ${sessionId}: ${message}`));
    gClient.setEventListener("Session.unprocessedRegions", () => { });
    gClient
        .sendCommand("Session.ensureProcessed", { level: "basic" }, null, sessionId)
        .then(() => waiter.resolve(null));
    const error = await waiter.promise;
    return error;
}
exports.connectionWaitForProcessed = connectionWaitForProcessed;
async function connectionReportCrash(data) {
    if (!gClient)
        throw new Error("Protocol client is not initialized");
    await gClient.sendCommand("Internal.reportCrash", { data });
}
exports.connectionReportCrash = connectionReportCrash;
// Granularity for splitting up a recording into chunks for uploading.
const ChunkGranularity = 1024 * 1024;
async function connectionUploadRecording(recordingId, contents) {
    if (!gClient)
        throw new Error("Protocol client is not initialized");
    const promises = [];
    for (let i = 0; i < contents.length; i += ChunkGranularity) {
        const buf = contents.subarray(i, i + ChunkGranularity);
        promises.push(gClient.sendCommand("Internal.addRecordingData", { recordingId, offset: i, length: buf.length }, buf));
    }
    // Explicitly mark the recording complete so the server knows that it has
    // been sent all of the recording data, and can save the recording.
    // This means if someone presses Ctrl+C, the server doesn't save a
    // partial recording.
    promises.push(gClient.sendCommand("Internal.finishRecording", { recordingId }));
    return Promise.all(promises);
}
exports.connectionUploadRecording = connectionUploadRecording;
async function connectionUploadSourcemap(recordingId, metadata, content) {
    if (!gClient)
        throw new Error("Protocol client is not initialized");
    const hash = "sha256:" + sha256(content);
    const { token } = await gClient.sendCommand("Resource.token", { hash });
    let resource = {
        token,
        saltedHash: "sha256:" + sha256(token + content),
    };
    const { exists } = await gClient.sendCommand("Resource.exists", { resource });
    if (!exists) {
        ({ resource } = await gClient.sendCommand("Resource.create", { content }));
    }
    const { baseURL, targetContentHash, targetURLHash, targetMapURLHash } = metadata;
    const result = await gClient.sendCommand("Recording.addSourceMap", {
        recordingId,
        resource,
        baseURL,
        targetContentHash,
        targetURLHash,
        targetMapURLHash,
    });
    return result.id;
}
exports.connectionUploadSourcemap = connectionUploadSourcemap;
function sha256(text) {
    return crypto_1.default.createHash("sha256").update(text).digest("hex");
}
function closeConnection() {
    if (gClient) {
        gClient.close();
        gClient = undefined;
        gClientReady = (0, utils_1.defer)();
    }
}
exports.closeConnection = closeConnection;
//# sourceMappingURL=upload.js.map