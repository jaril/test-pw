"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ws_1 = __importDefault(require("ws"));
const utils_1 = require("./utils");
class ProtocolClient {
    constructor(address, callbacks, opts = {}) {
        Object.defineProperty(this, "socket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pendingMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "eventListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "nextMessageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        this.socket = new ws_1.default(address, {
            agent: opts.agent,
        });
        this.callbacks = callbacks;
        this.socket.on("open", callbacks.onOpen);
        this.socket.on("close", callbacks.onClose);
        this.socket.on("error", callbacks.onError);
        this.socket.on("message", (message) => this.onMessage(message));
    }
    close() {
        this.socket.close();
    }
    async setAccessToken(accessToken) {
        accessToken = accessToken || process.env.RECORD_REPLAY_API_KEY;
        if (!accessToken) {
            throw new Error("Access token must be passed or set via the RECORD_REPLAY_API_KEY environment variable.");
        }
        return this.sendCommand("Authentication.setAccessToken", {
            accessToken,
        });
    }
    async sendCommand(method, params, data, sessionId) {
        const id = this.nextMessageId++;
        this.socket.send(JSON.stringify({
            id,
            method,
            params,
            binary: data ? true : undefined,
            sessionId,
        }));
        if (data) {
            this.socket.send(data);
        }
        const waiter = (0, utils_1.defer)();
        this.pendingMessages.set(id, waiter);
        return waiter.promise;
    }
    setEventListener(method, callback) {
        this.eventListeners.set(method, callback);
    }
    onMessage(contents) {
        const msg = JSON.parse(String(contents));
        if (msg.id) {
            const { resolve, reject } = this.pendingMessages.get(msg.id);
            this.pendingMessages.delete(msg.id);
            if (msg.result) {
                resolve(msg.result);
            }
            else {
                reject(`Channel error: ${JSON.stringify(msg)}`);
            }
        }
        else if (this.eventListeners.has(msg.method)) {
            this.eventListeners.get(msg.method)(msg.params);
        }
        else {
            console.log(`Received event without listener: ${msg.method}`);
        }
    }
}
exports.default = ProtocolClient;
//# sourceMappingURL=client.js.map